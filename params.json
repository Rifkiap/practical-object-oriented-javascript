{"name":"Practical-object-oriented-javascript","tagline":"Practical Object Oriented Javascript - CWC 2015 Workshop","body":"Practical Object Oriented Javascript - CWC 2015 Workshop\r\n========================================================\r\n\r\n... or getting closure on thissues™.\r\n\r\n\r\n\r\nWhat We Will Cover\r\n------------------\r\n\r\n * JavaScript primer, is it functional? is it object oriented? is it funcject orientional?\r\n * First class functions\r\n * Closures\r\n * WTF is `this`?\r\n * Why is `this` that?\r\n * Seriously WTF is `this` and how do I force it to make sense\r\n * Managing scope\r\n * Building an autocomplete widget with the OO building blocks\r\n\r\n\r\nFirst Class Functions\r\n---------------------\r\n\r\n * Functions are values just like strings, numbers, arrays, and objects\r\n * Functions can be assigned to variables and passed as arguments\r\n * Functions can be manipulated as values\r\n * Functions can be dynamically created by other functions\r\n\r\nFunction Assignment\r\n\r\n```js\r\nvar greeterCreator = function(greeting) {\r\n    return function(name) {\r\n        console.log(greeting + \" \" + name);\r\n    };\r\n};\r\n\r\nvar helloGreeter = greeterCreator(\"Hello\");\r\n\r\nhelloGreeter(\"Chicago Web Conf\");\r\n```\r\n\r\nDynamic Function Assignment\r\n\r\n```js\r\nvar myFunction = function() {\r\n  console.log(\"Hello World\");\r\n};\r\n\r\nvar myObject = {\r\n  myMethod: function() {\r\n    console.log(\"I'm a property of an object\");\r\n  }\r\n};\r\n\r\nmyFunction();\r\nmyObject.myMethod();\r\n```\r\n\r\n![Obligatory Mind Blown .gif](https://raw.githubusercontent.com/devmynd/practical-object-oriented-javascript/master/images/mind-blown.gif)\r\n\r\nScope\r\n-----\r\n\r\n`window` is the implicit global namespace. Leaked globals can be accessed on window.\r\n\r\nGlobal variables are implied when assigned without the `var` keyword. Basically, you should **NEVER** assign a variable without the `var` keyword. It is otherwise very easy to leak a function's member variable to the global scope:\r\n\r\nLeaked globals\r\n\r\n```js\r\nvar foo = 5;\r\nvar bar = 10;\r\n\r\nfunction logFoo() {\r\n  foo = 15;\r\n  var bar = 20;\r\n\r\n  console.log(\"logFoo scope\")\r\n  console.log(foo, bar);\r\n}\r\n\r\nlogFoo(); // 15, 20\r\n\r\nconsole.log(\"global scope (window)\")\r\nconsole.log(foo, bar); // 15, 10\r\nconsole.log(window.foo, window.bar); // 15, 10\r\n```\r\n\r\n### Closures\r\n\r\n Closures are an immediately invoked function, which usually return a function that has access to privately scoped members of the containing function. The outer function “closes over” the returned function, hence the term closure. The only way to create private methods/variables in JavaScript is to use a closure (for now).\r\n\r\n\r\n#### examples:\r\n\r\n```js\r\nvar tellSecrets = function() {\r\n  var secret = \"shh, don’t tell anyone\";\r\n  return function() {\r\n    console.log(secret);\r\n  };\r\n}();\r\n\r\ntellSecrets();\r\nconsole.log(secret); // undefined\r\n```\r\n\r\nObjects\r\n-------\r\n\r\nWhen we talk about Objects in JavaScript, we can be talking about 2 different things. The `Object` data type refers to a key-value pair; much like hashes, associative arrays, or maps in other languages. They are also refered to as JSON (javascript object notation) objects. Here are a few examples of simple JavaScript objects:\r\n\r\n#### examples:\r\n\r\nA basic object is a simple key-value store that can be arbitrarily nested:\r\n\r\n```js\r\nvar person = {\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  }\r\n};\r\n```\r\n\r\nAn object can have functions for properties (remember first class functions). When the property of an object is a function, we refer to these as methods:\r\n\r\n```js\r\nvar person = {\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  },\r\n  sayHello: function() {\r\n    console.log(\"Hi, my name is \" + this.firstName + \". I live in \" + this.address.city + \", on \" + this.address.street + \".\")\r\n  }\r\n};\r\n```\r\n\r\n### Instantiated Objects\r\n\r\nWhen we talk about objects in traditional object-oriented programming, we are talking about classes and instances. JavaScript *does not have* a traditional Class model. In fact, it does not have a \"Class\" at all (until recently). \"Classes\" in JavaScript are created by taking advantage of some interesting features of functions in JavaScript. The `new` keyword and the `this` keyword allow us to mimic the functionality of traditional Classes and inheritance patterns.\r\n\r\nTo create a \"Class\" in javascript, you must first define a function. Since there are no formal \"Classes\", always capitalize a function intended to be used as a \"Class\". This function is considered the `constructor`, which means this function will be executed every time a new instance of this \"Class\" is created, with a new context. \"Instance variables\" for each instance of the object can be assinged by using the `this` keyword. These are really just properties of the instantiated object.\r\n\r\n#### examples:\r\n\r\nTo instantiate a new instance of a \"Class\" use the `new` keyword:\r\n\r\n```js\r\nfunction Person(attributes) {\r\n  this.firstName = attributes.firstName;\r\n  this.lastName = attributes.lastName;\r\n  this.age = attributes.age;\r\n  this.address = attributes.address;\r\n}\r\n\r\nvar bob = new Person({\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  }\r\n);\r\n```\r\n\r\n*Warning if you do not use the `new` keyword when you instantiate a new object, the function will still be executed, returning undefined and leaking any properties assigned to the global scope*:\r\n\r\n```js\r\nfunction Person(attributes) {\r\n  this.firstName = attributes.firstName;\r\n  this.lastName = attributes.lastName;\r\n  this.age = attributes.age;\r\n  this.address = attributes.address;\r\n}\r\n\r\nvar bob = Person({\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  }\r\n);\r\n\r\nconsole.log(bob); // undefined\r\nconsole.log(window.firstName); // \"Bob\"\r\nconsole.log(window.lastName); // \"Ject\"\r\nconsole.log(window.age); // 33\r\nconsole.log(window.address); // [object Object] (address object)\r\n```\r\n\r\n### Instance Methods\r\n\r\nTo define instance methods the right way, we assign functions to the \"Class\" `prototype`. The `prototype` is an `Object` (the JSON kind) that contains the methods that each instance will share. Every instance can share these same methods because when called, they will be called in the context of that instance:\r\n\r\n```js\r\nfunction Person(attributes) {\r\n  this.firstName = attributes.firstName;\r\n  this.lastName = attributes.lastName;\r\n  this.age = attributes.age;\r\n  this.address = attributes.address;\r\n}\r\n\r\nPerson.prototype.sayHello = function() {\r\n  console.log(\"Hi, my name is \" + this.firstName + \". I live in \" + this.address.city + \", \" + this.address.state + \" on \" + this.address.street + \".\");\r\n};\r\n\r\nvar bob = Person({\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  }\r\n);\r\n\r\nvar ella = Person({\r\n  firstName: \"Ella\",\r\n  lastName: \"Siff\",\r\n  age: 1,\r\n  address: {\r\n    street: \"8362 Ram Rd\",\r\n    apt: \"0x7fff8637c02f\",\r\n    zip: \"10101\",\r\n    city: \"Tab City\",\r\n    state: \"Webkitesota\"\r\n  }\r\n);\r\n\r\nbob.sayHello(); // \"Hi, my name is Bob. I live in Browser Town, Mozilla on 123 Memory Ln.\"\r\nella.sayHello(); // \"Hi, my name is Ella. I live in Tab City, Webkitesota on 8362 Ram Rd.\"\r\n```\r\n\r\nThere is a naive way to define instance methods which has an impact on performace. DO NOT define instance methods as `this` properties in a \"Class\" `constructor`. This will create a new function in memory for each instance, which is expensive and unnecessary.\r\n\r\n```js\r\n// DO NOT define instance methods in this way\r\n\r\nfunction Person(attributes) {\r\n  this.firstName = attributes.firstName;\r\n  this.lastName = attributes.lastName;\r\n  this.age = attributes.age;\r\n  this.address = attributes.address;\r\n  this.sayHello = function() {\r\n    console.log(\"Hi, my name is \" + this.firstName + \". I live in \" + this.address.city + \", on \" + this.address.street + \".\")\r\n  };\r\n}\r\n```\r\n\r\n### Static or Class Methods\r\n\r\nSometimes, methods should not belong to any specific instance and instead belong to the \"Class\" itself. Traditionally we call these static or class methods. Since a \"Class\" in JavaScript is simply a function and functions are first-class and can have properties, we simply define a property on the \"Class\" function itself:\r\n\r\n```js\r\nfunction Person(attributes) {\r\n  this.firstName = attributes.firstName;\r\n  this.lastName = attributes.lastName;\r\n  this.age = attributes.age;\r\n  this.address = attributes.address;\r\n}\r\n\r\nPerson.marry = function(bride, groom) {\r\n  bride.spouse = groom;\r\n  groom.spouse = bride;\r\n}\r\n\r\nPerson.prototype.sayHello = function() {\r\n  console.log(\"Hi, my name is \" + this.firstName + \". I live in \" + this.address.city + \", \" + this.address.state + \" on \" + this.address.street + \".\");\r\n};\r\n\r\nvar bob = Person({\r\n  firstName: \"Bob\",\r\n  lastName: \"Ject\",\r\n  age: 33,\r\n  address: {\r\n    street: \"123 Memory Ln\",\r\n    apt: \"0x7fff9575c05f\",\r\n    zip: \"01101\",\r\n    city: \"Browser Town\",\r\n    state: \"Mozilla\"\r\n  }\r\n);\r\n\r\nvar ella = Person({\r\n  firstName: \"Ella\",\r\n  lastName: \"Siff\",\r\n  age: 1,\r\n  address: {\r\n    street: \"8362 Ram Rd\",\r\n    apt: \"0x7fff8637c02f\",\r\n    zip: \"10101\",\r\n    city: \"Tab City\",\r\n    state: \"Webkitesota\"\r\n  }\r\n);\r\n\r\nPerson.marry(ella, bob);\r\n\r\nbob.spouse === ella; // true\r\nella.spouse === bob; // true\r\n```\r\n\r\nThissues™\r\n---------\r\n\r\n`this` is a reference to the current context (object). The current context (object) is is not always what you expect. It can change what it references when a function is passed to other objects.Without a containing object, `this` refers to the global scope (window). Understanding `this` is crucial to writing solid object oriented JavaScript and will punish those who don’t understand it.\r\n\r\n#### examples:\r\n\r\nWhen there is no other containing scope `this` is `window`:\r\n\r\n```js\r\nfunction someFunction() {\r\n  console.log(this);\r\n}\r\n\r\nsomeFunction(); // window\r\n```\r\n\r\nIn nested anonymous functions `this` is still `window`:\r\n\r\n```js\r\n(function() {\r\n    console.log(this); // logs window\r\n\r\n    (function() {\r\n        console.log(this); // logs window\r\n    })();\r\n\r\n})();\r\n```\r\n\r\nIn an Object: `this` refers to the containing object:\r\n\r\n```js\r\nvar object = {\r\n    someMethod: function() {\r\n        console.log(this)\r\n    }\r\n};\r\n\r\nobject.someMethod(); // logs object\r\nobject[\"someMethod\"](); // logs object\r\n```\r\n\r\nWhen functions change scope: `this` becomes the new scope:\r\n\r\n```js\r\nvar object = {\r\n    someMethod: function() {\r\n        console.log(this)\r\n    }\r\n};\r\n\r\nvar someMethod = object.someMethod;\r\nsomeMethod(); // logs window\r\n```\r\n\r\nYou can force a function to use a give context use call or apply and pass the context:\r\n\r\n```js\r\nvar object = {};\r\nvar someFunction = function() {\r\n  console.log(this);\r\n  console.log(arguments);\r\n};\r\nsomeFunction.call(object, 'arg1', 'arg2'); // logs object then arg1 and arg2\r\n\r\n// is the same as\r\n\r\nsomeFunction.apply(object, ['arg1', 'arg2']); // logs object then arg1 and arg2\r\n```\r\n\r\nYou can pass on object to apply to bind the function's context to that object:\r\n\r\n```js\r\nvar object = {};\r\nvar someFunction = function() { console.log(this); };\r\n\r\nvar boundFunction = function() {\r\n  return someFunction.apply(object, arguments);\r\n};\r\n\r\nboundFunction(); // logs object\r\n```\r\n\r\nMost modern browsers support binding functions natively with the bind method:\r\n\r\n```js\r\nvar object = {};\r\nvar someFunction = function() { console.log(this); };\r\n\r\nvar boundFunction = someFunction.bind(object);\r\n\r\nboundFunction(); // logs object\r\n```\r\n\r\nLodash and other libraries provide context binding for browsers that don't support binding:\r\n\r\n```js\r\nvar object = {};\r\nvar someFunction = function() { console.log(this); };\r\n\r\nvar boundFunction = _.bind(someFunction, object);\r\nvar proxyBound = $.proxy(someFunction, object);\r\n\r\nboundFunction(); // logs object\r\nproxyBound(); // logs object\r\n```\r\n\r\n![Obligatory Mind Blown .gif](https://raw.githubusercontent.com/devmynd/practical-object-oriented-javascript/master/images/mind-blown.gif)\r\n\r\nBuilding An Autocomplete Widget\r\n-------------------------------\r\n\r\nCreating object-oriented widgets in JavaScript requires breaking down the desired functionality down into separate objects. We should think of an autocomplete widget as a collection of several objects. It helps to identify each object by visualizing the widget:\r\n\r\n![Autocomplete Diagram](https://raw.githubusercontent.com/devmynd/practical-object-oriented-javascript/master/images/autocomplete-diagram.png)\r\n\r\n * **Autocomplete** handles coordinating the objects\r\n * **Input** handles accepting text input and determining whether to handle text entry or commands\r\n * **List** handles showing, hiding, activating, and selecting list items\r\n * **List Item** handles interaction with the item\r\n\r\nThe benefits of this type of architecture is that it is easy to test, easy to extend and does not require traversing or reading the DOM. This helps hedge against unforseen errors when things in the markup change.\r\n\r\nAutocompleteInput\r\n-----------------\r\n\r\n### Starting Small\r\nIt's best to start with the smallest piece possible and then work your way up to the larger pieces. We'll start with the `AutocompleteInput`.\r\n\r\nEvery good start involves a test:\r\n\r\n```js\r\ndescribe(\"AutocompleteInput\", function() {\r\n  var subject;\r\n  var name;\r\n  var value;\r\n  var onTextEntrySpy;\r\n  var onCommandEntrySpy;\r\n  beforeEach(function() {\r\n    name = \"test\";\r\n    value = \"test value\";\r\n    onTextEntrySpy = sinon.spy();\r\n    onCommandEntrySpy = sinon.spy();\r\n    subject = new AutocompleteInput({\r\n      name: name,\r\n      value: value,\r\n      onTextEntry: onTextEntrySpy,\r\n      onCommandEntry: onCommandEntrySpy\r\n    });\r\n  });\r\n\r\n});\r\n```\r\n\r\n#### describe\r\n\r\nEach `describe` block is a way to group a set of tests under a given description. This helps keep the tests organized and readable.\r\n\r\n#### beforeEach\r\n\r\nThe `beforeEach` block is for shared test setup. Here we setup a new instance of our test subject for each test to prevent polluting the instance's state between tests. Notice the variable declarations are outside of the `beforeEach`block so the variables will be available to each test.\r\n\r\n#### afterEach\r\n\r\nIf we needed to do some clean up after each test we could use [`afterEach`](https://gist.github.com/crismali/2c284bd7f07cd3f8c68a).\r\n\r\n#### it\r\n\r\nEach `it` block consists of a descriptive string and a function containing our test assertions. Each `it` block is one test in our suite.\r\n\r\nTo begin, our `AutocompleteInput` requires a name and value to use for the input element. Although we could use separate arguments for the name and value, we'll instead use an object to keep our API clean and simple.\r\n\r\nLet's write our first test:\r\n\r\n```js\r\nit(\"requires a name attribute\", function() {\r\n  expect(function() {\r\n    new AutocompleteInput({ value: value });\r\n  }).to.throw(\"AutocompleteInput: name is undefined\");\r\n});\r\n```\r\n\r\nThis test asserts that we always pass in a name. Because JavaScript doesn't have default arguments, we need to make sure the attributes object exists before we test the properties on it. We can do this by setting the attributes to what was passed or an empty object: `attributes = attributes || {};` Now we can test that our `AutocompleteInput` requires certain attributes.\r\n\r\nWe don't want to rely on JavaScript throwing a vague error when a required attribute isn't given. The key to a solid API is being explicit and obvious with our requirements. Since our `AutocompleteInput` needs a name to do its job we need to throw an explicit error when none is given. To do this, we simply check for the property and throw a new `Error` when it is not present.\r\n\r\nAlthough we CAN throw any standard JavaScript error (ie. `ArgumentError`, `TypeError`), older Internet Explorer versions will quietly swallow any type of error except the plain old `Error`.\r\n\r\n```js\r\nfunction AutocompleteInput(attributes) {\r\n  ...\r\n\r\n  attributes = attributes || {};\r\n\r\n  if (_.isUndefined(this.attributes.name)) {\r\n    throw new Error(\"AutocompleteInput: name is undefined\");\r\n  }\r\n\r\n  ...\r\n}\r\n```\r\n\r\nThis should get our first test passing. Now we want to do the same thing with value.\r\n\r\n```js\r\nit(\"requires a value\", function() {\r\n  expect(function() {\r\n    new AutocompleteInput({ name: name });\r\n  }).to.throw(\"AutocompleteInput: value is undefined\");\r\n});\r\n```\r\n\r\nNow to make it pass:\r\n\r\n```js\r\nfunction AutocompleteInput(attributes) {\r\n  ...\r\n\r\n  attributes = attributes || {};\r\n\r\n  if (_.isUndefined(attributes.name)) {\r\n    throw new Error(\"AutocompleteInput: name is undefined\");\r\n  }\r\n\r\n  if (_.isUndefined(attributes.value)) {\r\n    throw new Error(\"AutocompleteInput: value is undefined\");\r\n  }\r\n\r\n  ...\r\n}\r\n```\r\n\r\nNow we want to make sure it sets the attributes correctly on the object itself:\r\n\r\n```js\r\nit(\"has a name with `_autocomplete_input` appended\", function() {\r\n  expect(subject.name).to.equal(name + \"_autocomplete_input\");\r\n});\r\n\r\nit(\"has a value\", function() {\r\n  expect(subject.value).to.equal(value);\r\n});\r\n```\r\n\r\n```js\r\nfunction AutocompleteInput(attributes) {\r\n  ...\r\n\r\n  this.name = attributes.name + \"_autocomplete_input\";\r\n  this.value = attributes.value;\r\n\r\n  ...\r\n}\r\n```\r\n\r\nNow we want to make sure our `AutocompleteInput` creates and saves a reference to the jQuery wrapped element that will represent it on the page.\r\n\r\n```js\r\nit(\"has an element\", function() {\r\n  expect(subject.$el).to.exist;\r\n  expect(subject.$el).to.have.class(\"autocomplete-input\");\r\n  expect(subject.$el).to.have.attr(\"name\", name + \"_autocomplete_input\");\r\n  expect(subject.$el).to.have.attr(\"value\", value);\r\n});\r\n```\r\n\r\nAnd to make this pass:\r\n\r\n```js\r\nfunction AutocompleteInput(attributes) {\r\n  ...\r\n\r\n  this.$el = $(\"<input name='\" + this.name + \"' value='\" + this.value + \"' />\");\r\n\r\n  ...\r\n}\r\n```\r\n\r\nOur input's main responsibility is determining whether or not a key press was a query or a command, but it doesn't need to know what happens after that in either case. Our input will accept callbacks to handle each case.\r\n\r\nUp in our `beforeEach` block we set up some spies, now we can take advantage of them. Spies allows us to test whether or not these functions are called and what arguments were passed to them. Since we don't know whether or not the calling code cares about what happens in either case. We create default callbacks that do nothing.\r\n\r\n```js\r\n...\r\n\r\nit(\"accepts a callback for text entry\", function() {\r\n  expect(subject.onTextEntry).to.equal(onTextEntrySpy);\r\n});\r\n\r\nit(\"accepts a callback for command entry\", function() {\r\n  expect(subject.onCommandEntry).to.equal(onCommandEntrySpy);\r\n});\r\n\r\ndescribe(\"default callbacks\", function() {\r\n  beforeEach(function() {\r\n    subject = new AutocompleteInput({\r\n      name: name,\r\n      value: value\r\n    });\r\n  });\r\n\r\n  it(\"has a default onTextEntry handler\", function() {\r\n    expect(subject.onTextEntry).to.be.a(\"function\");\r\n  });\r\n\r\n  it(\"has a default onCommandEntry handler\", function() {\r\n    expect(subject.onCommandEntry).to.be.a(\"function\");\r\n  });\r\n});\r\n\r\n...\r\n```\r\n\r\n```js\r\nfunction AutocompleteInput(attributes) {\r\n  ...\r\n\r\n  _.defaults(attributes, {\r\n    onTextEntry: function() {},\r\n    onCommandEntry: function() {}\r\n  });\r\n\r\n  this.onTextEntry = attributes.onTextEntry;\r\n  this.onCommandEntry = attributes.onCommandEntry;\r\n\r\n  ...\r\n}\r\n```\r\n\r\nTo determine if the user has typed in a text character or a command key, we'll need a list of key codes that match up to keypresses we consider commands. The \"commands\" we accept are:\r\n\r\n * The `esc` key to cancel completion and hide the list\r\n * The `enter` key to select a currently active completion\r\n * The `up` key to navigate up the completion list\r\n * The `down` key to navigate down the completion list\r\n\r\nTo do this, we're going to create a map of key codes and their corresponding key. Because the key codes are not unique to each instance, we're going to store this map on the `AutocompleteInput` \"Class\" itself:\r\n\r\n```js\r\nit(\"has a command keycodes constant\", function() {\r\n  expect(AutocompleteInput.CMD_KEYCODES.up).to.equal(38);\r\n  expect(AutocompleteInput.CMD_KEYCODES.down).to.equal(40);\r\n  expect(AutocompleteInput.CMD_KEYCODES.escape).to.equal(27);\r\n  expect(AutocompleteInput.CMD_KEYCODES.enter).to.equal(13);\r\n\r\n  expect(AutocompleteInput.CMD_KEYCODES[38]).to.equal(\"up\");\r\n  expect(AutocompleteInput.CMD_KEYCODES[40]).to.equal(\"down\");\r\n  expect(AutocompleteInput.CMD_KEYCODES[27]).to.equal(\"escape\");\r\n  expect(AutocompleteInput.CMD_KEYCODES[13]).to.equal(\"enter\");\r\n});\r\n```\r\n\r\nWe expect an object defined on the `AutocompleteInput` itself to define a map of key codes to keys and vice versa so it's easy to get a key name referenced by key code and a key code referenced by key name:\r\n\r\n```js\r\nfunction AutocompleteInput() {\r\n  ...\r\n}\r\n\r\nAutocompleteInput.CMD_KEYCODES = {\r\n  up: 38,\r\n  down: 40,\r\n  escape: 27,\r\n  enter: 13\r\n};\r\n\r\nAutocompleteInput.CMD_KEYCODES = _.merge(AutocompleteInput.CMD_KEYCODES, _.invert(AutocompleteInput.CMD_KEYCODES));\r\n```\r\n\r\nNow we have a way to know when a command key is entered into the input.\r\n\r\nIt's time to start defining instance methods and properties on our `AutocompleteInput`. Instead of typing `AutocompleteInput.prototype.someFunction = ...` for every method. We'll use lodash's `merge` method to cut down on the noise.\r\n\r\nThe `merge` method takes the properties of one object, and copies them over to another object. This means we can `merge` a plain object containing our instance methods onto the `AutocompleteInut`'s prototype:\r\n\r\n```js\r\n_.merge(AutocompleteInput.prototype, {\r\n  someMethod: function() {\r\n    ...\r\n  }\r\n});\r\n```\r\n\r\nIt looks a bit strange at first but it's better than all the extra noise.\r\n\r\nIt's time to do a slight refactor. Since we're using lodash, we'd like a cleaner way to create template strings than concatenating strings together. Lodash's `template` method is perfect for this. The `template` method accepts a string with specially formatted placeholders for interpolation when the template is rendered. The `template` method returns a function that accepts an object with keys corresponding to it's placeholders. Let's refactor our element to use a lodash `template`:\r\n\r\n```js\r\ndescribe(\"#template\", function() {\r\n  var templateValues;\r\n  var renderedTemplate;\r\n  beforeEach(function() {\r\n    templateValues = {\r\n      name: \"test_name\",\r\n      value: \"test_value\"\r\n    };\r\n    renderedTemplate = subject.template(templateValues);\r\n  });\r\n\r\n  it(\"is an input\", function() {\r\n    expect(renderedTemplate).to.match(/^\\<input/);\r\n  });\r\n\r\n  it(\"has a name parameter\", function() {\r\n    expect(renderedTemplate).to.match(/name=\\'test_name\\'/);\r\n  });\r\n\r\n  it(\"has a value parameter\", function() {\r\n    expect(renderedTemplate).to.match(/value=\\'test_value\\'/);\r\n  });\r\n\r\n  it(\"has an autocomplete-input class\", function() {\r\n    expect(renderedTemplate).to.match(/class=\\'autocomplete-input\\'/);\r\n  });\r\n});\r\n```\r\n\r\nNow we need to create a template to make these pass:\r\n\r\n```js\r\n_.merge(AutocompleteInput.prototype, {\r\n  template: _.template(\"<input name='<%= name %>' class='autocomplete-input' value='<%= value %>' />\")\r\n})\r\n```\r\n\r\nNow every instance of an `AutocompleteInput` will have a template method that can generate the markup it needs.\r\n\r\nThe next thing our `AutocompleteInput` needs to do is determine when a command key is pressed. Let's create an `isCommandKey` method to determine what key was pressed with a given key code:\r\n\r\n```js\r\ndescribe(\"#isCommandKey\", function() {\r\n  it(\"returns true when a command keyCode is given\", function() {\r\n    expect(subject.isCommandKey(38)).to.be.true;\r\n    expect(subject.isCommandKey(40)).to.be.true;\r\n    expect(subject.isCommandKey(27)).to.be.true;\r\n    expect(subject.isCommandKey(13)).to.be.true;\r\n  });\r\n\r\n  it(\"returns false when a non command keyCode is given\", function() {\r\n    expect(subject.isCommandKey(84)).to.be.false;\r\n  });\r\n});\r\n```\r\n\r\nNow we can simply use the given key code and our `CMD_KEYCODES` map to find a match:\r\n\r\n```js\r\n_.merge(AutocompleteInput.prototype, {\r\n  ...\r\n\r\n  isCommandKey: function(keyCode) {\r\n    return _.contains(AutocompleteInput.CMD_KEYCODES, keyCode);\r\n  },\r\n\r\n  ...\r\n});\r\n```\r\n\r\nThe last thing our `AutocompleteInput` needs to do is call our text input and command callbacks when keys are pressed. Here is where we get into using spies to test how and when functions are called. We use a spy when we want to determine if a method was called and what arguments were passed to it. In this case we need to test that the proper handlers are called when a key is pressed:\r\n\r\n```js\r\ndescribe(\"#onKeyup\", function() {\r\n  describe(\"command\", function() {\r\n    beforeEach(function() {\r\n      subject.handleKeyup({ keyCode: AutocompleteInput.CMD_KEYCODES.enter });\r\n    });\r\n\r\n    it(\"does not call the onTextEntry callback\", function() {\r\n      expect(subject.attributes.onTextEntry).to.not.have.been.called;\r\n    });\r\n\r\n    it(\"calls the onCommandEntry callback with the given command\", function() {\r\n      expect(subject.attributes.onCommandEntry).to.have.been.calledWith(\"enter\");\r\n    });\r\n  });\r\n\r\n  describe(\"text\", function() {\r\n    beforeEach(function() {\r\n      subject.$el.val(\"test\");\r\n      subject.handleKeyup({ keyCode: 84 });\r\n    });\r\n\r\n    it(\"calls the onTextEntry callback\", function() {\r\n      expect(subject.attributes.onTextEntry).to.have.been.calledWith(\"test\");\r\n    });\r\n\r\n    it(\"does not call the onCommandEntry callback with the given command\", function() {\r\n      expect(subject.attributes.onCommandEntry).not.to.have.been.called;\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nNow we simply utilize our `isCommandKey` method to determine which handler to call:\r\n\r\n```js\r\n_.merge(AutocompleteInput.prototype, {\r\n  ...\r\n\r\n  handleKeyup: function(evnt) {\r\n    if (this.isCommandKey(evnt.keyCode)) {\r\n      var command = AutocompleteInput.CMD_KEYCODES[evnt.keyCode];\r\n      this.attributes.onCommandEntry(command);\r\n    } else {\r\n      this.attributes.onTextEntry(this.$el.val());\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nThat's all our `AutocompleteInput` needs to do. It's small, easy to test, and extendable.\r\n\r\nAutocompleteListItem\r\n--------------------\r\n\r\nThe next part of functionality of an autocompleter is a completion list but since we're working from small to large, we'll start with the list items before we get to the list.\r\n\r\nA list item's job is very simple. It need to store the value and text of the item, activate and deactivate the highlight on the item, and select the item when it is clicked. Let's take care of the basics:\r\n\r\n```js\r\ndescribe(\"AutocompleteListItem\", function() {\r\n  var subject;\r\n  var testText;\r\n  var testValue;\r\n  var onSelectSpy;\r\n\r\n  beforeEach(function() {\r\n    testText = \"Test Item\";\r\n    testValue = 1;\r\n    onSelectSpy = sinon.spy();\r\n    subject = new AutocompleteListItem({\r\n      onSelect: onSelectSpy,\r\n      item: {\r\n        value: testValue,\r\n        text: testText\r\n      }\r\n    });\r\n  });\r\n\r\n  it(\"has an element\", function() {\r\n    expect(subject.$el).to.exist;\r\n    expect(subject.$el).to.have.class(\"autocomplete-list-item\");\r\n    expect(subject.$el[0].tagName).to.equal(\"LI\");\r\n  });\r\n\r\n  it(\"has a value\", function() {\r\n    expect(subject.value).to.equal(testValue);\r\n  });\r\n\r\n  it(\"has text\", function() {\r\n    expect(subject.text).to.equal(testText);\r\n  });\r\n\r\n  it(\"has a template\", function() {\r\n    expect(subject.template).to.be.a(\"function\");\r\n    var renderedTemplate = subject.template({ text: \"foo\" });\r\n    expect(renderedTemplate).to.match(/foo/);\r\n  });\r\n\r\n  it(\"has an onSelect handler\", function() {\r\n    expect(subject.onSelect).to.be.a(\"function\");\r\n  });\r\n\r\n  it(\"has a active state\", function() {\r\n    expect(subject.active).to.be.false;\r\n  });\r\n\r\n  describe(\"#activate\", function() {\r\n    beforeEach(function() {\r\n      subject.activate();\r\n    });\r\n\r\n    it(\"sets active to true\", function() {\r\n      expect(subject.active).to.be.true;\r\n    });\r\n\r\n    it(\"adds the active class to el\", function() {\r\n      expect(subject.$el).to.have.class(\"active\");\r\n    });\r\n  });\r\n\r\n  describe(\"#deactivate\", function() {\r\n    beforeEach(function() {\r\n      subject.active = true;\r\n      subject.$el.addClass(\"active\");\r\n      subject.deactivate();\r\n    });\r\n\r\n    it(\"sets active to false\", function() {\r\n      expect(subject.active).to.be.false;\r\n    });\r\n\r\n    it(\"removes the active class from el\", function() {\r\n      expect(subject.$el).to.not.have.class(\"active\");\r\n    });\r\n  });\r\n\r\n  describe(\"#select\", function() {\r\n    it(\"calls the onClick function, passing itself\", function() {\r\n      subject.select();\r\n      expect(subject.onClick).to.have.been.calledWith(subject);\r\n    });\r\n  });\r\n\r\n  describe(\"#registerEvents\", function() {\r\n    it(\"handles click\", function() {\r\n      subject.$el.trigger(\"click\");\r\n      expect(subject.onClick).to.have.been.called;\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\nThis handles creating a DOM element for each list item and it's properties, as well as activating and deactivating the item and calling the handlers when an item is selected:\r\n\r\n```js\r\nfunction AutocompleteListItem(attributes) {\r\n  _.bindAll(this);\r\n  attributes = attributes || {};\r\n  _.defaults(attributes, {\r\n    onSelect: function() {}\r\n  });\r\n\r\n  this.value = attributes.item.value;\r\n  this.text = attributes.item.text;\r\n  this.onSelect = attributes.onSelect;\r\n\r\n  this.$el = $(this.template({\r\n    value: this.value,\r\n    text: this.text\r\n  }));\r\n  this.active = false;\r\n\r\n  this.registerEvents();\r\n}\r\n\r\n_.merge(AutocompleteListItem.prototype, {\r\n\r\n  template: _.template('<li class=\"autocomplete-list-item\"><a href=\"#\"><%= text %></a></li>'),\r\n\r\n  activate: function() {\r\n    this.active = true;\r\n    this.$el.addClass(\"active\");\r\n  },\r\n\r\n  deactivate: function() {\r\n    this.active = false;\r\n    this.$el.removeClass(\"active\");\r\n  },\r\n\r\n  registerEvents: function() {\r\n    this.$el.on(\"click\", this.select);\r\n  },\r\n\r\n  select: function() {\r\n    this.onSelect(this);\r\n  }\r\n\r\n});\r\n```\r\n\r\nOur `AutocompleteListItem` \"Class\" is complete. Now we need a list to manage them:\r\n\r\nAutocompleteList\r\n----------------\r\n\r\n```js\r\ndescribe(\"AutocompleteList\", function() {\r\n  var subject;\r\n  var item1;\r\n  var item2;\r\n  var item3;\r\n  var items;\r\n  var onItemSelectSpy;\r\n  beforeEach(function() {\r\n    item1 = { value: 1, text: \"Test item 1\" };\r\n    item2 = { value: 2, text: \"Test item 2\" };\r\n    item3 = { value: 3, text: \"Test item 3\" };\r\n    items = [item1, item2, item3];\r\n    onItemSelectSpy = sinon.spy();\r\n    subject = new AutocompleteList({ onItemSelect: onItemSelectSpy });\r\n  });\r\n\r\n  it(\"has an element\", function() {\r\n    expect(subject.$el).to.exist;\r\n    expect(subject.$el[0].tagName).to.equal(\"UL\");\r\n    expect(subject.$el).to.have.class(\"autocomplete-list\");\r\n    expect(subject.$el).to.have.class(\"hidden\");\r\n  });\r\n\r\n  it(\"has an onItemSelect handler\", function() {\r\n    expect(subject.onItemSelect).to.equal(onItemSelectSpy);\r\n  });\r\n\r\n  describe(\"defaults\", function() {\r\n    beforeEach(function() {\r\n      subject = new AutocompleteList();\r\n    });\r\n\r\n    it(\"has an onItemSelect handler\", function() {\r\n      expect(subject.onItemSelect).to.be.a(\"function\");\r\n    });\r\n  });\r\n\r\n  describe(\"#render\", function() {\r\n    beforeEach(function() {\r\n      subject.render(items);\r\n    });\r\n\r\n    it(\"creates an completionListItem for each item\", function() {\r\n      expect(subject.items).to.be.an(\"Array\");\r\n      expect(subject.items.length).to.equal(items.length);\r\n      _.each(subject.items, function(item) {\r\n        expect(item).to.be.an.instanceof(AutocompleteListItem);\r\n      });\r\n    });\r\n\r\n    it(\"appends each item to the element\", function() {\r\n      expect(subject.$el).to.have.descendants(\"li\");\r\n    });\r\n\r\n    it(\"removes the hidden class\", function() {\r\n      expect(subject.$el).not.to.have.class(\"hidden\");\r\n    });\r\n\r\n    it(\"does not double render the items\", function() {\r\n      subject.render(items);\r\n      expect(subject.$el.find(\"li\").length).to.equal(items.length);\r\n    });\r\n\r\n    describe(\"when there are no items\", function() {\r\n      beforeEach(function() {\r\n        subject.$el.removeClass(\"hidden\");\r\n        subject.$el.empty();\r\n      });\r\n\r\n      it(\"it adds the hidden class\", function() {\r\n        subject.render([]);\r\n        expect(subject.$el).to.have.class(\"hidden\");\r\n      });\r\n\r\n      it(\"does not throw an error when items are undefined\", function() {\r\n        expect(function() {\r\n          subject.render();\r\n        }).not.to.throw();\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#hide\", function() {\r\n    it(\"adds the hidden class to the element\", function() {\r\n      subject.$el.removeClass(\"hidden\");\r\n      subject.hide();\r\n      expect(subject.$el).to.have.class(\"hidden\");\r\n    });\r\n  });\r\n\r\n  describe(\"#show\", function() {\r\n    it(\"removes the hidden class from the element\", function() {\r\n      subject.$el.addClass(\"hidden\");\r\n      subject.show();\r\n      expect(subject.$el).not.to.have.class(\"hidden\");\r\n    });\r\n  });\r\n\r\n  describe(\"#handleItemSelect\", function() {\r\n    var selectedItem;\r\n    beforeEach(function() {\r\n      subject.render(items);\r\n      subject.show();\r\n      selectedItem = _.first(subject.items);\r\n      subject.handleItemSelect(selectedItem);\r\n    });\r\n\r\n    it(\"calls the onItemSelect callback, passing the item clicked\", function() {\r\n      expect(subject.onItemSelect).to.have.been.calledWith(selectedItem);\r\n    });\r\n\r\n    it(\"hides the completion list\", function() {\r\n      expect(subject.$el).to.have.class(\"hidden\");\r\n    });\r\n  });\r\n\r\n  describe(\"#activeItem\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n    });\r\n\r\n    it(\"returns undefined when no item is active\", function() {\r\n      expect(subject.activeItem()).to.be.undefined;\r\n    });\r\n\r\n    it(\"returns the active item when one is active\", function() {\r\n      var activeItem = _.first(subject.items);\r\n      activeItem.activate();\r\n      expect(subject.activeItem()).to.equal(activeItem);\r\n    });\r\n  });\r\n\r\n  describe(\"#nextItem\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n    });\r\n\r\n    describe(\"when no items are active\", function() {\r\n      it(\"returns the first item\", function() {\r\n        expect(subject.nextItem()).to.equal(_.first(subject.items));\r\n      });\r\n    });\r\n\r\n    describe(\"when an item is active\", function() {\r\n      beforeEach(function() {\r\n        _.first(subject.items).activate();\r\n      });\r\n\r\n      it(\"returns the next item in the items array\", function() {\r\n        expect(subject.nextItem()).to.equal(subject.items[1]);\r\n      });\r\n    });\r\n\r\n    describe(\"when the last item is already active\", function() {\r\n      it(\"returns the first item\", function() {\r\n        _.last(subject.items).activate();\r\n        expect(subject.nextItem()).to.equal(_.first(subject.items));\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#activateNextItem\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n    });\r\n\r\n    describe(\"when no items are active\", function() {\r\n      it(\"activates the first item\", function() {\r\n        subject.activateNextItem();\r\n        expect(_.first(subject.items).active).to.be.true;\r\n      });\r\n    });\r\n\r\n    describe(\"when an item is active\", function() {\r\n      beforeEach(function() {\r\n        _.first(subject.items).activate();\r\n        subject.activateNextItem();\r\n      });\r\n\r\n      it(\"activates the next item in the items array\", function() {\r\n        expect(subject.items[1].active).to.be.true;\r\n      });\r\n\r\n      it(\"deactivates the previously active item\", function() {\r\n        expect(_.first(subject.items).active).to.be.false;\r\n      });\r\n    });\r\n\r\n    describe(\"when the last item is already active\", function() {\r\n      it(\"activates the first item\", function() {\r\n        _.last(subject.items).activate();\r\n        subject.activateNextItem();\r\n        expect(_.first(subject.items).active).to.be.true;\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#previousItem\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n    });\r\n\r\n    describe(\"when no items are active\", function() {\r\n      it(\"returns the last item\", function() {\r\n        expect(subject.previousItem()).to.equal(_.last(subject.items));\r\n      });\r\n    });\r\n\r\n    describe(\"when an item is active\", function() {\r\n      beforeEach(function() {\r\n        _.last(subject.items).activate();\r\n      });\r\n\r\n      it(\"returns the next item in the items array\", function() {\r\n        expect(subject.previousItem()).to.equal(subject.items[1]);\r\n      });\r\n    });\r\n\r\n    describe(\"when the first item is already active\", function() {\r\n      it(\"returns the last item\", function() {\r\n        _.first(subject.items).activate();\r\n        expect(subject.previousItem()).to.equal(_.last(subject.items));\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#activatePreviousItem\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n    });\r\n\r\n    describe(\"when no items are active\", function() {\r\n      it(\"activates the last item\", function() {\r\n        subject.activatePreviousItem();\r\n        expect(_.last(subject.items).active).to.be.true;\r\n      });\r\n    });\r\n\r\n    describe(\"when an item is active\", function() {\r\n      beforeEach(function() {\r\n        _.last(subject.items).activate();\r\n        subject.activatePreviousItem();\r\n      });\r\n\r\n      it(\"activates the previous item in the items array\", function() {\r\n        expect(subject.items[1].active).to.be.true;\r\n      });\r\n\r\n      it(\"deactivates the previously active item\", function() {\r\n        expect(_.last(subject.items).active).to.be.false;\r\n      });\r\n    });\r\n\r\n    describe(\"when the first item is already active\", function() {\r\n      it(\"activates the last item\", function() {\r\n        _.first(subject.items).activate();\r\n        subject.activatePreviousItem();\r\n        expect(_.last(subject.items).active).to.be.true;\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#handleCommandEntry\", function() {\r\n    beforeEach(function() {\r\n      sinon.stub(subject, \"handleUp\");\r\n      sinon.stub(subject, \"handleDown\");\r\n      sinon.stub(subject, \"handleEnter\");\r\n      sinon.stub(subject, \"handleEscape\");\r\n    });\r\n\r\n    describe(\"up\", function() {\r\n      beforeEach(function() {\r\n        subject.handleCommandEntry(\"up\");\r\n      });\r\n\r\n      it(\"handles up\", function() {\r\n        expect(subject.handleUp).to.have.been.called;\r\n        expect(subject.handleDown).to.not.have.been.called;\r\n        expect(subject.handleEnter).to.not.have.been.called;\r\n        expect(subject.handleEscape).to.not.have.been.called;\r\n      });\r\n    });\r\n\r\n    describe(\"down\", function() {\r\n      beforeEach(function() {\r\n        subject.handleCommandEntry(\"down\");\r\n      });\r\n\r\n      it(\"handles down\", function() {\r\n        expect(subject.handleDown).to.have.been.called;\r\n        expect(subject.handleUp).to.not.have.been.called;\r\n        expect(subject.handleEnter).to.not.have.been.called;\r\n        expect(subject.handleEscape).to.not.have.been.called;\r\n      });\r\n    });\r\n\r\n    describe(\"enter\", function() {\r\n      beforeEach(function() {\r\n        subject.handleCommandEntry(\"enter\");\r\n      });\r\n\r\n      it(\"handles enter\", function() {\r\n        expect(subject.handleEnter).to.have.been.called;\r\n        expect(subject.handleUp).to.not.have.been.called;\r\n        expect(subject.handleDown).to.not.have.been.called;\r\n        expect(subject.handleEscape).to.not.have.been.called;\r\n      });\r\n    });\r\n\r\n    describe(\"escape\", function() {\r\n      beforeEach(function() {\r\n        subject.handleCommandEntry(\"escape\");\r\n      });\r\n\r\n      it(\"handles escape\", function() {\r\n        expect(subject.handleEscape).to.have.been.called;\r\n        expect(subject.handleUp).to.not.have.been.called;\r\n        expect(subject.handleDown).to.not.have.been.called;\r\n        expect(subject.handleEnter).to.not.have.been.called;\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#handleDown\", function() {\r\n    beforeEach(function() {\r\n      sinon.spy(subject, \"activateNextItem\");\r\n      subject.createListItems(items);\r\n      subject.handleDown();\r\n    });\r\n\r\n    it(\"activates the next item\", function() {\r\n      expect(subject.activateNextItem).to.have.been.called;\r\n    });\r\n  });\r\n\r\n  describe(\"#handleUp\", function() {\r\n    beforeEach(function() {\r\n      subject.createListItems(items);\r\n      sinon.spy(subject, \"activatePreviousItem\");\r\n      subject.handleUp();\r\n    });\r\n\r\n    it(\"activates the previous item\", function() {\r\n      expect(subject.activatePreviousItem).to.have.been.called;\r\n    });\r\n  });\r\n\r\n  describe(\"#handleEscape\", function() {\r\n    beforeEach(function() {\r\n      sinon.spy(subject, \"hide\");\r\n      subject.handleEscape();\r\n    });\r\n\r\n    it(\"hides the list\", function() {\r\n      expect(subject.hide).to.have.been.called;\r\n    });\r\n  });\r\n\r\n  describe(\"#handleEnter\", function() {\r\n    describe(\"when an item is active\", function() {\r\n      var item;\r\n      beforeEach(function() {\r\n        subject.createListItems(items);\r\n        item = _.first(subject.items);\r\n        item.activate();\r\n        sinon.spy(item, \"select\");\r\n        subject.handleEnter();\r\n      });\r\n\r\n      it(\"selects the active item\", function() {\r\n        expect(item.select).to.have.been.called;\r\n      });\r\n    });\r\n\r\n    describe(\"when there is no active item\", function() {\r\n      it(\"does not throw an error\", function() {\r\n        expect(function() {\r\n          subject.handleEnter();\r\n        }).not.to.throw();\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\nThis is the busiest \"Class\" in the autocompleter, which makes sense. It needs to handle rendering the list items, activating and deactivating items when the list is navigated, and hiding and showing the list when certain commands are entered. Thankfully TDD makes this a straight-forward and simple process:\r\n\r\n```js\r\nfunction AutocompleteList(attributes) {\r\n  _.bindAll(this);\r\n  attributes = attributes || {};\r\n  _.defaults(attributes, {\r\n    onItemSelect: function() {}\r\n  });\r\n\r\n  this.onItemSelect = attributes.onItemSelect;\r\n  this.$el = $(\"<ul class='autocomplete-list hidden'/>\");\r\n}\r\n\r\n_.merge(AutocompleteList.prototype, {\r\n\r\n  render: function(items) {\r\n    this.$el.empty();\r\n    if (_.isEmpty(items)) {\r\n      this.hide();\r\n    } else {\r\n      this.createListItems(items);\r\n      this.renderItems();\r\n      this.show();\r\n    }\r\n  },\r\n\r\n  hide: function() {\r\n    this.$el.addClass(\"hidden\");\r\n  },\r\n\r\n  show: function() {\r\n    this.$el.removeClass(\"hidden\");\r\n  },\r\n\r\n  createListItems: function(items) {\r\n    this.items = _.map(items, this.createListItem);\r\n  },\r\n\r\n  createListItem: function(item) {\r\n    return new AutocompleteListItem({ item: item, onSelect: this.handleItemSelect });\r\n  },\r\n\r\n  handleItemSelect: function(item) {\r\n    this.onItemSelect(item);\r\n    this.hide();\r\n  },\r\n\r\n  renderItems: function() {\r\n    _.each(this.items, this.renderItem);\r\n  },\r\n\r\n  renderItem: function(item) {\r\n    this.$el.append(item.$el);\r\n  },\r\n\r\n  activeItem: function() {\r\n    return _.find(this.items, \"active\");\r\n  },\r\n\r\n  nextItem: function() {\r\n    var nextIndex = _.indexOf(this.items, this.activeItem()) + 1;\r\n    var nextItem = this.items[nextIndex] || _.first(this.items);\r\n    return nextItem;\r\n  },\r\n\r\n  activateNextItem: function() {\r\n    var currentlySelected = this.activeItem();\r\n    this.nextItem().activate();\r\n    if (currentlySelected) {\r\n      currentlySelected.deactivate();\r\n    }\r\n  },\r\n\r\n  previousItem: function() {\r\n    var previousIndex = _.indexOf(this.items, this.activeItem()) - 1;\r\n    var previousItem = this.items[previousIndex] || _.last(this.items);\r\n    return previousItem;\r\n  },\r\n\r\n  activatePreviousItem: function() {\r\n    var currentlySelected = this.activeItem();\r\n    this.previousItem().activate();\r\n    if (currentlySelected) {\r\n      currentlySelected.deactivate();\r\n    }\r\n  },\r\n\r\n  handleCommandEntry: function(command) {\r\n    this[\"handle\" + _.capitalize(command)]();\r\n  },\r\n\r\n  handleDown: function() {\r\n    this.activateNextItem();\r\n  },\r\n\r\n  handleUp: function() {\r\n    this.activatePreviousItem();\r\n  },\r\n\r\n  handleEnter: function() {\r\n    var activeItem = this.activeItem();\r\n    if (activeItem) {\r\n      activeItem.select();\r\n    }\r\n  },\r\n\r\n  handleEscape: function() {\r\n    this.hide();\r\n  }\r\n\r\n});\r\n```\r\n\r\nNow that we have our DOM components created we need to create the objects that will handle actually auto completing text when entered into the input. We'd like to be able to either provide a list of items to complete or a URL to a server endpoint that will fetch completions. Since this behavior is slightly different in each case, we'll create adapters to handle each of them. Let's start with an adapter for filtering a provided list:\r\n\r\nAutocompleteLocalAdapter\r\n------------------------\r\n\r\n```js\r\ndescribe(\"AutocompleteLocalAdapter\", function() {\r\n  var subject;\r\n  var items;\r\n  var onAutocompleteSpy;\r\n  beforeEach(function() {\r\n    items = [\r\n      { value: 1, text: \"Test item 1\" },\r\n      { value: 2, text: \"Test item 2\" },\r\n      { value: 3, text: \"Test item 3\" }\r\n    ];\r\n    onAutocompleteSpy = sinon.spy();\r\n    subject = new AutocompleteLocalAdapter({\r\n      items: items,\r\n      onAutocomplete: onAutocompleteSpy\r\n    });\r\n  });\r\n\r\n  it(\"requires items\", function() {\r\n    expect(function() {\r\n      new AutocompleteLocalAdapter;\r\n    }).to.throw(\"AutocompleteLocalAdapter: items is undefined\");\r\n  });\r\n\r\n  it(\"has an onAutocomplete callback\", function() {\r\n    expect(subject.onAutocompleteSpy).to.equal(onAutocompleteSpy);\r\n  });\r\n\r\n  describe(\"defaults\", function() {\r\n    beforeEach(function() {\r\n      subject = new AutocompleteLocalAdapter({\r\n        items: items\r\n      });\r\n    });\r\n\r\n    it(\"has a default onAutocomplete handler\", function() {\r\n      expect(subject.onAutocomplete).to.be.a(\"function\");\r\n    });\r\n  });\r\n\r\n  describe(\"#handleTextEntry\", function() {\r\n    describe(\"when empty text is passed\", function() {\r\n      it(\"calls the onAutocomplete callback, passing an empty array of items\", function() {\r\n        subject.handleTextEntry(\"\");\r\n        expect(subject.onAutocomplete).to.have.been.calledWith([]);\r\n      });\r\n    });\r\n\r\n    describe(\"when text is passed\", function() {\r\n      beforeEach(function() {\r\n        subject.handleTextEntry(\"Test item 3\");\r\n      });\r\n\r\n      it(\"calls the onAutocomplete callback, passing an array of matching items\", function() {\r\n        expect(subject.onAutocomplete).to.have.been.calledWith([_.last(items)]);\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nAnd now the implementation:\r\n\r\n```js\r\nfunction AutocompleteLocalAdapter(attributes) {\r\n  _.bindAll(this);\r\n  attributes = attributes || {};\r\n  _.defaults(attributes, {\r\n    onAutocomplete: function() {}\r\n  });\r\n\r\n  if (_.isUndefined(attributes.items)) {\r\n    throw new Error(\"AutocompleteLocalAdapter: items is undefined\");\r\n  }\r\n\r\n  this.items = attributes.items;\r\n  this.onAutocomplete = attributes.onAutocomplete;\r\n}\r\n\r\n_.merge(AutocompleteLocalAdapter.prototype, {\r\n\r\n  handleTextEntry: function(text) {\r\n    var items = [];\r\n    if (text) {\r\n      this.filter = new RegExp(\"^\" + text, \"i\");\r\n      items = _.filter(this.items, this.itemMatchesFilter);\r\n    }\r\n    this.onAutocomplete(items);\r\n  },\r\n\r\n  itemMatchesFilter: function(item) {\r\n    return item.text.match(this.filter);\r\n  }\r\n\r\n});\r\n```\r\n\r\nAutocompleteAjaxAdapter\r\n-----------------------\r\n\r\nNow let's make an adapter to handle fetching completions from a remote server with an AJAX adapter:\r\n\r\n\r\nIt can be tricky to test asynchronous functions like AJAX calls. This is where sinon comes to the rescue. Sinon lets us mock out AJAX request and perform assertions without actually calling out to a remote server. To do this, we need to set up fake XHR request handling:\r\n\r\n```js\r\n...\r\n\r\nvar xhr;\r\nvar requests;\r\nbeforeEach(function() {\r\n  ...\r\n\r\n  xhr = sinon.useFakeXMLHttpRequest();\r\n  requests = [];\r\n  xhr.onCreate = function(xhr) {\r\n    requests.push(xhr);\r\n  };\r\n\r\n  ...\r\n})\r\n```\r\n\r\nNow whenever an AJAX request is made in our code, it will be captured in the `requests` array. Let's write some tests:\r\n\r\n```js\r\ndescribe(\"AutocompleteAjaxAdapter\", function() {\r\n  var subject;\r\n  var onAutocomplete;\r\n  var xhr;\r\n  var requests;\r\n  beforeEach(function() {\r\n    xhr = sinon.useFakeXMLHttpRequest();\r\n    requests = [];\r\n    xhr.onCreate = function(xhr) {\r\n      requests.push(xhr);\r\n    };\r\n    onAutocomplete = sinon.spy();\r\n    subject = new AutocompleteAjaxAdapter({\r\n      url: \"test\",\r\n      onAutocomplete: onAutocomplete\r\n    });\r\n  });\r\n\r\n  it(\"requires a url\", function() {\r\n    expect(function() {\r\n      new AutocompleteAjaxAdapter;\r\n    }).to.throw(\"AutocompleteAjaxAdapter: url is undefined\");\r\n  });\r\n\r\n  it(\"has a url\", function() {\r\n    expect(subject.url).to.equal(\"test\");\r\n  });\r\n\r\n  it(\"has an onAutocomplete handler\", function() {\r\n    expect(subject.onAutocomplete).to.equal(onAutocompleteSpy);\r\n  });\r\n\r\n  it(\"has a throttle delay\", function() {\r\n    expect(subject.throttleDelay).to.be.a(\"number\");\r\n  });\r\n\r\n  describe(\"defaults\", function() {\r\n    beforeEach(function() {\r\n      subject = new AutocompleteAjaxAdapter({\r\n        url: \"test\"\r\n      });\r\n    });\r\n\r\n    it(\"has a default onAutocomplete handler\", function() {\r\n      expect(subject.onAutocomplete).to.be.a(\"function\");\r\n    });\r\n  });\r\n\r\n  describe(\"#handleTextEntry\", function() {\r\n    var text;\r\n    beforeEach(function() {\r\n      text = \"test query\";\r\n      sinon.spy(window, \"clearTimeout\");\r\n      sinon.spy(subject, \"queueRequest\");\r\n    });\r\n\r\n    afterEach(function() {\r\n      clearTimeout.restore();\r\n    });\r\n\r\n    it(\"sets the query\", function() {\r\n      subject.handleTextEntry(text);\r\n      expect(subject.query).to.equal(text);\r\n    });\r\n\r\n    it(\"queues a request\", function() {\r\n      subject.handleTextEntry(text);\r\n      expect(subject.queueRequest).to.have.been.called;\r\n    });\r\n\r\n    describe(\"when there's a queued request\", function() {\r\n      it(\"clears the timeout\", function() {\r\n        subject.queuedRequest = 5;\r\n        subject.handleTextEntry(text);\r\n        expect(clearTimeout).to.have.been.calledWith(5);\r\n      });\r\n    });\r\n\r\n    describe(\"when there is not a queued request\", function() {\r\n      it(\"does nothing\", function() {\r\n        subject.handleTextEntry(text);\r\n        expect(clearTimeout).not.to.have.been.called;\r\n      });\r\n    });\r\n\r\n    describe(\"when the text is empty\", function() {\r\n      it(\"does not queue a request\", function() {\r\n        subject.handleTextEntry(\"\");\r\n        expect(subject.queuedRequest).to.be.undefined;\r\n      });\r\n\r\n      it(\"clears a request out\", function() {\r\n        subject.queuedRequest = 15;\r\n        subject.handleTextEntry(\"\");\r\n        expect(clearTimeout).to.have.been.calledWith(subject.queuedRequest);\r\n      });\r\n\r\n      it(\"sends an empty array to the on autocomplete callback\", function() {\r\n        subject.handleTextEntry(\"\");\r\n        expect(subject.onAutocomplete).to.have.been.calledWith([]);\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#fetchItems\", function() {\r\n    it(\"gets the items via ajax\", function() {\r\n      subject.fetchItems();\r\n      var request = _.last(requests);\r\n      expect(request.url).to.equal(subject.url);\r\n      expect(request.method).to.equal(\"GET\");\r\n      expect(request.requestHeaders.Accept).to.match(/application\\/json/);\r\n    });\r\n  });\r\n\r\n  describe(\"#queueRequest\", function() {\r\n    beforeEach(function() {\r\n      subject.throttleDelay = 0;\r\n      sinon.spy(window, \"setTimeout\");\r\n      sinon.spy(subject, \"fetchItems\");\r\n      subject.queueRequest();\r\n    });\r\n\r\n    afterEach(function() {\r\n      setTimeout.restore();\r\n    });\r\n\r\n    it(\"queues a fetch items request\", function() {\r\n      expect(subject.queuedRequest).to.be.a(\"number\");\r\n    });\r\n\r\n    it(\"fetches the items after the throttle delay\", function() {\r\n      expect(setTimeout).to.have.been.called;\r\n\r\n      var args = _.first(setTimeout.args);\r\n      var callback = _.first(args);\r\n      var throttleDelay = _.last(args);\r\n      callback();\r\n      expect(subject.fetchItems).to.have.been.called;\r\n      expect(throttleDelay).to.equal(subject.throttleDelay);\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nWith a sturdy test harness underneath us we can confidently implement this adapter:\r\n\r\n```js\r\nfunction AutocompleteAjaxAdapter(attributes) {\r\n  _.bindAll(this);\r\n  attributes = attributes || {};\r\n  _.defaults(attributes, {\r\n    onAutocomplete: function() {}\r\n  });\r\n\r\n  if (_.isUndefined(attributes.url)) {\r\n    throw new Error(\"AutocompleteAjaxAdapter: url is undefined\");\r\n  }\r\n\r\n  this.url = attributes.url;\r\n  this.onAutocomplete = attributes.onAutocomplete;\r\n  this.throttleDelay = 250;\r\n}\r\n\r\n_.merge(AutocompleteAjaxAdapter.prototype, {\r\n\r\n  handleTextEntry: function(text) {\r\n    this.query = text;\r\n    if (this.queuedRequest) {\r\n      clearTimeout(this.queuedRequest);\r\n    }\r\n    if (!text) {\r\n      this.onAutocomplete([]);\r\n      return;\r\n    }\r\n    this.queueRequest();\r\n  },\r\n\r\n  fetchItems: function() {\r\n    $.ajax({\r\n      url: this.url,\r\n      type: \"get\",\r\n      dataType: \"json\",\r\n      data: { query: this.query }\r\n    })\r\n      .done(this.onAutocomplete);\r\n  },\r\n\r\n  queueRequest: function() {\r\n    var _this = this;\r\n    this.queuedRequest = setTimeout(function() {\r\n      _this.fetchItems();\r\n    }, this.throttleDelay);\r\n  }\r\n\r\n});\r\n```\r\n\r\nAutocomplete\r\n------------\r\n\r\nAll that's left is to create an object to wrangle all these pieces together:\r\n\r\n```js\r\ndescribe(\"Autocomplete\", function() {\r\n  var subject;\r\n  var items;\r\n  beforeEach(function() {\r\n    appendFixture(\"input\", { id: \"autocomplete\", type: \"text\", name: \"autocomplete\" });\r\n    items = [\r\n      { value: 1, text: \"Test item 1\" },\r\n      { value: 2, text: \"Test item 2\" },\r\n      { value: 3, text: \"Test item 3\" }\r\n    ];\r\n    subject = new Autocomplete({ selector: \"#autocomplete\", url: \"test\" });\r\n  });\r\n\r\n  it(\"requires a selector\", function() {\r\n    expect(function() {\r\n      new Autocomplete;\r\n    }).to.throw(\"Autocomplete: selector is undefined\");\r\n  });\r\n\r\n  it(\"requires a url or an items array\", function() {\r\n    expect(function() {\r\n      new Autocomplete({ selector: \"#autocomplete\" });\r\n    }).to.throw(\"Autocomplete: items or url is undefined\");\r\n  });\r\n\r\n  describe(\"initialize\", function() {\r\n    it(\"has a reference to the input\", function() {\r\n      expect(subject.$input).to.exist;\r\n      expect(subject.$input).to.have.id(\"autocomplete\");\r\n      expect(subject.$input[0].tagName).to.equal(\"INPUT\");\r\n    });\r\n\r\n    it(\"wraps the element in an .autocomplete-container\", function() {\r\n      expect(subject.$el).to.exist;\r\n      expect(subject.$el).to.have.class(\"autocomplete-container\");\r\n    });\r\n\r\n    it(\"hides the original input\", function() {\r\n      expect(subject.$input).not.to.be.visible;\r\n    });\r\n\r\n    it(\"creates a filter input\", function() {\r\n       var expectedName = subject.$input.attr(\"name\") + \"_autocomplete_input\";\r\n      expect(subject.autocompleteInput).to.be.an.instanceof(AutocompleteInput);\r\n      expect(subject.autocompleteInput.name).to.equal(expectedName);\r\n      expect(subject.autocompleteInput.value).to.equal(subject.$input.val());\r\n      expect(subject.autocompleteInput.onTextEntry).to.equal(subject.adapter.handleTextEntry);\r\n      expect(subject.autocompleteInput.onCommandEntry).to.equal(subject.completionList.handleCommandEntry);\r\n    });\r\n\r\n    it(\"creates a list for autocompleted items\", function() {\r\n      expect(subject.completionList).to.be.an.instanceof(AutocompleteList);\r\n      expect(subject.completionList.onItemSelect).to.equal(subject.handleItemSelect);\r\n    });\r\n\r\n    it(\"has a default onAutocomplete callback\", function() {\r\n      expect(subject.onAutocomplete).to.be.a(\"function\");\r\n    });\r\n\r\n    describe(\"onAutocomplete callback\", function() {\r\n      it(\"sets the onAutocomplete callback\", function() {\r\n        var callback = function() {};\r\n        subject = new Autocomplete({\r\n          selector: \"#autocomplete\",\r\n          items: items,\r\n          onAutocomplete: callback\r\n        });\r\n\r\n        expect(subject.onAutocomplete).to.equal(callback);\r\n      });\r\n    });\r\n\r\n    describe(\"when items are passed\", function() {\r\n      it(\"has a local adapter\", function() {\r\n        subject = new Autocomplete({\r\n          selector: \"#autocomplete\",\r\n          items: items\r\n        });\r\n        expect(subject.adapter).to.be.an.instanceof(AutocompleteLocalAdapter);\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"#render\", function() {\r\n    it(\"appends the autocomplete input to the element\", function() {\r\n      expect(subject.$el).to.have.descendants(\".autocomplete-input\");\r\n    });\r\n\r\n    it(\"appends the autocomplete list to the element\", function() {\r\n      expect(subject.$el).to.have.descendants(\".autocomplete-list\");\r\n    });\r\n  });\r\n\r\n  describe(\"#handleItemSelect\", function() {\r\n    var item;\r\n    beforeEach(function() {\r\n      sinon.spy(subject, \"onAutocomplete\");\r\n      item = new AutocompleteListItem({ item: _.first(items) });\r\n      subject.handleItemSelect(item);\r\n    });\r\n\r\n    it(\"sets the $input's value to the item's value\", function() {\r\n      expect(subject.$input.val()).to.equal(item.value.toString());\r\n    });\r\n\r\n    it(\"displays the item's text in the autocomplete input\", function() {\r\n      expect(subject.autocompleteInput.$el).to.have.value(item.text);\r\n    });\r\n\r\n    it(\"calls the onAutocomplete callback, passing it the selected item\", function() {\r\n      expect(subject.onAutocomplete).to.have.been.calledWith(item);\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\nAnd here's the implementation:\r\n\r\n```js\r\nfunction Autocomplete(attributes) {\r\n  _.bindAll(this);\r\n  attributes = attributes || {};\r\n\r\n  if (_.isUndefined(attributes.selector)) {\r\n    throw new Error(\"Autocomplete: selector is undefined\");\r\n  }\r\n  if (_.isUndefined(attributes.items || attributes.url)) {\r\n    throw new Error(\"Autocomplete: items or url is undefined\");\r\n  }\r\n\r\n  this.initialize(attributes.selector, attributes.items || attributes.url, attributes.onAutocomplete);\r\n}\r\n\r\n_.merge(Autocomplete.prototype, {\r\n\r\n  initialize: function(selector, itemsOrUrl, onAutocomplete) {\r\n    this.onAutocomplete = onAutocomplete || function() {};\r\n    this.setupInput(selector);\r\n    this.$el = this.$input.parent();\r\n    this.completionList = new AutocompleteList({ onItemSelect: this.handleItemSelect });\r\n    this.createAdapter(itemsOrUrl);\r\n    this.autocompleteInput = new AutocompleteInput({\r\n      name: this.$input.attr(\"name\"),\r\n      value: this.$input.val(),\r\n      onTextEntry: this.adapter.handleTextEntry,\r\n      onCommandEntry: this.completionList.handleCommandEntry\r\n    });\r\n    this.render();\r\n  },\r\n\r\n  setupInput: function(selector) {\r\n    this.$input = $(selector);\r\n    this.$input.wrap(\"<div class='autocomplete-container' />\");\r\n    this.$input.hide();\r\n  },\r\n\r\n  createAdapter: function(itemsOrUrl) {\r\n    if (_.isArray(itemsOrUrl)) {\r\n      this.adapter = new AutocompleteLocalAdapter({\r\n        items: itemsOrUrl,\r\n        onAutocomplete: this.completionList.render\r\n      });\r\n    } else {\r\n      this.adapter = new AutocompleteAjaxAdapter({\r\n        url: itemsOrUrl,\r\n        onAutocomplete: this.completionList.render\r\n      });\r\n    }\r\n  },\r\n\r\n  render: function() {\r\n    this.$el.append(this.autocompleteInput.$el);\r\n    this.$el.append(this.completionList.$el);\r\n  },\r\n\r\n  handleItemSelect: function(item) {\r\n    this.$input.val(item.value);\r\n    this.autocompleteInput.$el.val(item.text);\r\n    this.onAutocomplete(item);\r\n  }\r\n\r\n});\r\n```\r\n\r\nThat should complete our sweet Autocomplete widget :)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}